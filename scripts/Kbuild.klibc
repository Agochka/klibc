# ==========================================================================
# Support for building klibc and related programs
# ==========================================================================
#
# To create a kbuild file for a userspace program do the following:
#
# Kbuild:
# 
# static-y := cat
# # This will compile a file named cat.c -> the executable 'cat'
# # The executable will be linked statically
#
# shared-y := cats
# # This will compile a file named cats.c -> the executable 'cats'
# # The executable will be linked shared
#
# If the user space program consist of more files do the following:
# Kbuild:
#
# static-y   := ipconfig
# ipconfig-y := main.o netdev.c
# So ipconfig will be linked statically using the two .o files
# specified with ipconfig-y.
#
# To set directory wide CFLAGS use:
# EXTRA_USERCFLAGS := -DDEBUG
# To set directory wide AFLAGS use:
# EXTRA_USERAFLAGS := -DDEBUG
#
# To set target specific CFLAGS (for .c files) use
# USERCFLAGS-main.o := -DDEBUG=3
# To set target specific AFLAGS (for .s files) use
# USERAFLAGS-main.o := -DDEBUG=3

src := $(obj)
# Preset target and make sure it is a ':=' variable
targets :=

.phony: __build
__build:

# Generic Kbuild routines
include $(srctree)/scripts/Kbuild.include

# Defines used when compiling early userspace (klibc programs)
# ---------------------------------------------------------------------------

# Arch specific definitions for klibc
include $(KLIBSRC)/arch/$(ARCH)/MCONFIG

USERWARNFLAGS   := -W -Wall -Wsign-compare

USERCROSS       := $(CROSS_COMPILE)

USERLD          := $(USERCROSS)ld
USERCC          := $(USERCROSS)gcc
USERAR          := $(USERCROSS)ar
USERRANLIB      := $(USERCROSS)ranlib
USERSTRIP       := $(USERCROSS)strip
USERNM          := $(USERCROSS)nm

USERCPPFLAGS    := -I$(KLIBINC)/arch/$(ARCH)                             \
                   -I$(KLIBINC)/bits$(BITSIZE)                           \
                   -I$(KLIBINC)                                          \
                   -Iinclude                                             \
                   $(if $(KBUILD_SRC),-Iinclude2 -I$(srctree)/include)   \
                   -D__KLIBC__=1 -D__KLIBC_MINOR__=0                     \
		   -DBITSIZE=$(BITSIZE)
USERCFLAGS      := $(USERCPPFLAGS) $(REQFLAGS) $(ARCHREQFLAGS)           \
                   $(OPTFLAGS) $(USERWARNFLAGS)
USERAFLAGS      := -D__ASSEMBLY__ $(USERCPPFLAGS)
USERSTRIPFLAGS  := --strip-all -R .comment -R .note

USERLIBGCC      := $(shell $(USERCC) --print-libgcc)
USERSHAREDFLAGS := $(SHAREDFLAGS)
USERCRT0        := $(KLIBOBJ)/arch/$(ARCH)/crt0.o
USERLIBC        := $(KLIBOBJ)/libc.a
USERCRTSHARED   := $(KLIBOBJ)/interp.o
USERLIBCSHARED  := $(KLIBOBJ)/libc.so

#
# This indicates the location of the final version of the shared library.
# THIS MUST BE AN ABSOLUTE PATH WITH NO FINAL SLASH.
# Leave this empty to make it the root.
#
SHLIBDIR = /lib

export USERLD USERCC USERAR USERSTRIP USERNM
export USERCFLAGS USERAFLAGS USERLIBGCC USERSHAREDFLAGS USERSTRIPFLAGS
export USERCRT0 USERLIBC SHLIBDIR

# kernel configuration
include .config

# Add $(obj)/ for paths that is not absolute
objectify = $(foreach o,$(1),$(if $(filter /%,$(o)),$(o),$(obj)/$(o)))

# Kbuild file in the directory that is being build
include $(obj)/Kbuild

#####
# static-y + shared-y handling
user-progs := $(static-y) $(shared-y)
# user-progs based on a single .o file (with same name + .o)
user-objs := $(foreach p, $(user-progs), $(if $($(p)-y),,$(p)))
user-objs := $(addsuffix .o, $(user-objs))
# user-progs which is based on several .o files
user-multi := $(foreach p, $(user-progs), $(if $($(p)-y),$(p)))
# objects used for user-progs with more then one .o file
user-objs += $(foreach p, $(user-multi), $($(p)-y))
# objects build in this dir
user-real-objs := $(patsubst %/,,$(user-objs))
# Directories we need to visit before user-objs are up-to-date
user-dirs :=  $(patsubst %/,%,$(filter %/, $(user-objs))) 
# replace all dir/ with dir/built-in.o
user-objs := $(patsubst %/, %/built-in.o, $(user-objs))

targets += $(static-y) $(shared-y)

# $(output-dirs) are a list of directories that contain object files
output-dirs := $(dir $(user-dirs))
output-dirs += $(foreach f, $(hostprogs-y) $(targets), \
               $(if $(dir $(f)), $(dir $(f))))
output-dirs := $(strip $(sort $(filter-out ./,$(output-dirs))))

# prefix so we get full dir
static-y        := $(addprefix $(obj)/,$(static-y))
shared-y        := $(addprefix $(obj)/,$(shared-y))
user-objs       := $(addprefix $(obj)/,$(user-objs))
user-real-objs  := $(addprefix $(obj)/,$(user-real-objs))
output-dirs     := $(addprefix $(obj)/,$(output-dirs))
user-dirs       := $(addprefix $(obj)/,$(user-dirs))
subdir-y        := $(addprefix $(obj)/,$(subdir-y))
obj-y           := $(addprefix $(obj)/,$(obj-y))
always          := $(addprefix $(obj)/,$(always))
targets         := $(addprefix $(obj)/,$(targets))


_usercflags    = $(USERCFLAGS) $(EXTRA_USERCFLAGS) $(USERCFLAGS_$(*F).o)
_useraflags    = $(USERAFLAGS) $(EXTRA_USERAFLAGS) $(USERAFLAGS_$(*F).o)

usercflags     = -Wp,-MD,$(depfile) $(NOSTDINC_FLAGS) $(_usercflags)
useraflags     = -Wp,-MD,$(depfile) $(NOSTDINC_FLAGS) $(_useraflags)

# Create output directory if not already present
_dummy := $(shell [ -d $(obj) ] || mkdir -p $(obj))

# Create directories for object files if directory does not exist
# Needed when obj-y := dir/file.o syntax is used
_dummy := $(foreach d,$(output-dirs), $(shell [ -d $(d) ] || mkdir -p $(d)))

# Do we have to make a built-in.o in this dir?
ifneq ($(strip $(obj-y) $(obj-n) $(obj-)),)
builtin-target := $(obj)/built-in.o
endif

__build: $(subdir-y) $(builtin-target) $(always)
	@:

# Compile C sources (.c)
# ---------------------------------------------------------------------------

quiet_cmd_cc_s_c = USERCC  $@
      cmd_cc_s_c = $(USERCC) $(usercflags) -S -o $@ $< 

%.s: %.c FORCE
	$(call if_changed_dep,cc_s_c)

quiet_cmd_cc_i_c = USERCPP $@
      cmd_cc_i_c = $(USERCPP) $(usercflags)   -o $@ $<

%.i: %.c FORCE
	$(call if_changed_dep,cc_i_c)

quiet_cmd_cc_o_c = USERCC  $@
      cmd_cc_o_c = $(USERCC) $(usercflags) -c -o $@ $<

%.o: %.c FORCE
	$(call if_changed_dep,cc_o_c)

# Compile assembler sources (.S)
# ---------------------------------------------------------------------------

quiet_cmd_as_s_S = USERCPP $@
      cmd_as_s_S = $(USERCPP) $(useraflags)   -o $@ $< 

%.s: %.S FORCE
	$(call if_changed_dep,as_s_S)

quiet_cmd_as_o_S = USERAS  $@
      cmd_as_o_S = $(USERCC) $(useraflags) -c -o $@ $<

%.o: %.S FORCE
	$(call if_changed_dep,as_o_S)

targets += $(real-objs-y)

#
# Rule to compile a set of .o files into one .o file
#
ifdef builtin-target
quiet_cmd_link_o_target = LD      $@
# If the list of objects to link is empty, just create an empty built-in.o
cmd_link_o_target = $(if $(strip $(obj-y)),\
                    $(USERLD) $(USERLDFLAGS) -r -o $@ $(filter $(obj-y), $^),\
                    rm -f $@; $(AR) rcs $@)

$(builtin-target): $(obj-y) FORCE
	$(call if_changed,link_o_target)
targets += $(builtin-target)
endif # builtin-target


ifdef user-progs
# Compile userspace programs for the target
# ===========================================================================

__build : $(user-dirs) $(static-y) $(shared-y)

# Descend if needed
$(sort $(addsuffix /built-in.o,$(user-dirs))): $(user-dirs) ;

# Define dependencies for link of progs
# For the simple program:
#	file.o => file
# A program with multiple objects
#	filea.o, fileb.o => file
# A program with .o files in another dir
#	dir/built-in.o filea.o => file

stripobj = $(subst $(obj)/,,$@)
addbuiltin = $(addprefix $(obj)/, $(patsubst %/, %/built-in.o, $(1)))
link-deps = $(if $($(stripobj)-y), $(call addbuiltin, $($(stripobj)-y)), $@.o) 

quiet_cmd_ld-static = USERLD  $@
      cmd_ld-static = $(USERLD) $(USERLDFLAGS) -o $@      \
                       $(USERCRT0)                        \
                       $(link-deps)                       \
                       $(USERLIBC) $(USERLIBGCC)

$(static-y): $(user-objs) FORCE
	$(call if_changed,ld-static)

quiet_cmd_ld-shared = USERLD  $@
      cmd_ld-shared = $(USERLD) $(USERLDFLAGS) -o $@      \
                       -e main $(USERCRTSHARED)           \
                       $(link-deps)                       \
                       $(USERLIBCSHARED) $(USERLIBGCC)
		       
$(shared-y): $(user-objs) FORCE
	$(call if_changed,ld-shared)
	
targets += $(user-real-objs)
endif

# Compile programs on the host
# ===========================================================================
ifdef hostprogs-y
include $(srctree)/scripts/Makefile.host
endif

# Descending
# ---------------------------------------------------------------------------

.PHONY: $(subdir-y) $(user-dirs)
$(subdir-y) $(user-dirs):
	$(Q)$(MAKE) $(klibc)=$@

# Add FORCE to the prequisites of a target to force it to be always rebuilt.
# ---------------------------------------------------------------------------

.PHONY: FORCE

FORCE:

# Linking
# Create a reloctable composite object file
# ---------------------------------------------------------------------------
quiet_cmd_userld = USERLD  $@
      cmd_userld = $(USERLD) -r $(USERLDFLAGS) \
                                $(EXTRA_USERLDFLAGS) $(USERLDFLAGS_$(@F)) \
                                $(filter-out FORCE,$^) -o $@


# Link target to a new name
# ---------------------------------------------------------------------------
quiet_cmd_ln = LN      $@
      cmd_ln = rm -f $@ && ln $< $@

# Strip target (remove all debugging info)
quiet_cmd_strip = STRIP   $@
      cmd_strip = $(USERSTRIP) $(USERSTRIPFLAGS) $< -o $@
 

# Read all saved command lines and dependencies for the $(targets) we
# may be building above, using $(if_changed{,_dep}). As an
# optimization, we don't need to read them if the target does not
# exist, we will rebuild anyway in that case.
targets := $(wildcard $(sort $(targets)))
cmd_files := $(wildcard $(foreach f,$(targets),$(dir $(f)).$(notdir $(f)).cmd))

ifneq ($(cmd_files),)
  include $(cmd_files)
endif

# Shorthand for $(Q)$(MAKE) -f scripts/Kbuild.klibc obj
# Usage:
# $(Q)$(MAKE) $(klibc)=dir
klibc := -rR -f $(if $(KBUILD_SRC),$(srctree)/)scripts/Kbuild.klibc obj

